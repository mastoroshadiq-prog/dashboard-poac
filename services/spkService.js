/**
 * SPK SERVICE - Business Logic Layer
 * 
 * KATEGORI 2: Tuntunan Backend - API INPUT/WRITE
 * Sub-Proses 1 & 2: INTEL & PLAN + EKSEKUSI & LAPOR
 * 
 * Filosofi 3P:
 * - SIMPLE: Logic bisnis terpisah dari routing
 * - TEPAT: Validasi data, Jejak Digital 5W1H mandatory
 * - PENINGKATAN BERTAHAB: Auto-trigger Work Order baru
 * 
 * Tuntunan Keamanan: 
 * - Semua input dari HP harus divalidasi ulang di server
 * - UserID dari JWT (jangan percaya input manual)
 * - Timestamp server (bukan dari HP)
 * 
 * Tuntunan Skalabilitas:
 * - Transaction untuk operasi multi-tabel
 * - Indexing pada kolom yang sering di-query
 */

const { supabase } = require('../config/supabase');

// ============================================================
// FITUR M-4.1: CREATE SPK HEADER
// ============================================================

/**
 * Create SPK Header (Induk Penugasan)
 * 
 * TUJUAN: Insert data SPK baru ke tabel spk_header
 * FITUR: M-4.1
 * SUB-PROSES: SP-1 (Intel & Plan) - Organizing
 * 
 * INPUT:
 * {
 *   nama_spk: string (required, max 255),
 *   id_asisten_pembuat: string (required, FK ke master_pihak),
 *   tanggal_target_selesai: string (optional, ISO 8601 date),
 *   keterangan: string (optional, max 5000)
 * }
 * 
 * OUTPUT:
 * {
 *   id_spk: string (UUID generated by Supabase),
 *   nama_spk: string,
 *   id_asisten_pembuat: string,
 *   tanggal_dibuat: string (ISO 8601 timestamp, server-side),
 *   tanggal_target_selesai: string,
 *   status_spk: string (default: 'BARU'),
 *   keterangan: string
 * }
 * 
 * VALIDASI BISNIS:
 * 1. id_asisten_pembuat harus exist di tabel master_pihak (FK constraint)
 * 2. status_spk default = 'BARU'
 * 3. tanggal_dibuat diambil dari server (getdate()), bukan dari client
 * 
 * ERROR HANDLING:
 * - Throw error jika INSERT gagal
 * - Error FK violation akan di-catch oleh router layer
 */
async function createSpkHeader(spkData) {
  try {
    console.log('ðŸ“ [Service] Creating SPK Header...');
    console.log('   Input:', JSON.stringify(spkData, null, 2));
    
    // Prinsip KEAMANAN: Sanitasi input
    // Trim whitespace dari semua string inputs
    const sanitizedData = {
      nama_spk: spkData.nama_spk.trim(),
      id_asisten_pembuat: spkData.id_asisten_pembuat.trim(),
      // Optional fields
      tanggal_target_selesai: spkData.tanggal_target_selesai || null,
      keterangan: spkData.keterangan ? spkData.keterangan.trim() : null
    };
    
    // Prinsip TEPAT: Validasi business rule - id_asisten_pembuat harus exist
    // (Di real world, kita cek dulu ke master_pihak, tapi Supabase FK akan handle ini)
    const { data: asistenExists, error: checkError } = await supabase
      .from('master_pihak')
      .select('id_pihak')
      .eq('id_pihak', sanitizedData.id_asisten_pembuat)
      .single();
    
    if (checkError || !asistenExists) {
      throw new Error(`ID Asisten Pembuat '${sanitizedData.id_asisten_pembuat}' tidak ditemukan di master_pihak`);
    }
    
    console.log('âœ… ID Asisten valid:', asistenExists.id_pihak);
    
    // INSERT ke tabel spk_header
    // Catatan: 
    // - id_spk akan auto-generated oleh Supabase (DEFAULT gen_random_uuid())
    // - tanggal_dibuat akan auto-filled oleh Supabase (DEFAULT now())
    // - status_spk akan auto-filled oleh Supabase (DEFAULT 'BARU')
    const { data, error } = await supabase
      .from('spk_header')
      .insert([
        {
          nama_spk: sanitizedData.nama_spk,
          id_asisten_pembuat: sanitizedData.id_asisten_pembuat,
          tanggal_target_selesai: sanitizedData.tanggal_target_selesai,
          keterangan: sanitizedData.keterangan
          // id_spk, tanggal_dibuat, status_spk akan auto-generated
        }
      ])
      .select(); // PENTING: .select() untuk return data yang baru di-insert
    
    if (error) {
      console.error('âŒ [Service] Supabase INSERT error:', error);
      throw new Error(`Gagal insert SPK Header: ${error.message}`);
    }
    
    if (!data || data.length === 0) {
      throw new Error('Gagal insert SPK Header: No data returned');
    }
    
    const newSpk = data[0];
    console.log('âœ… [Service] SPK Header created successfully!');
    console.log('   ID SPK:', newSpk.id_spk);
    console.log('   Status:', newSpk.status_spk);
    console.log('   Tanggal Dibuat:', newSpk.tanggal_dibuat);
    
    // Return data sesuai kontrak API
    return {
      id_spk: newSpk.id_spk,
      nama_spk: newSpk.nama_spk,
      id_asisten_pembuat: newSpk.id_asisten_pembuat,
      tanggal_dibuat: newSpk.tanggal_dibuat,
      tanggal_target_selesai: newSpk.tanggal_target_selesai,
      status_spk: newSpk.status_spk,
      keterangan: newSpk.keterangan
    };
    
  } catch (err) {
    console.error('âŒ [Service] Error in createSpkHeader:', err.message);
    throw err; // Re-throw untuk di-catch oleh router layer
  }
}

// ============================================================
// FITUR M-4.2: ADD TUGAS KE SPK (BATCH INSERT)
// ============================================================

/**
 * Add Tugas ke SPK (Batch Insert)
 * 
 * TUJUAN: Insert multiple tugas ke tabel spk_tugas dalam satu transaksi
 * FITUR: M-4.2
 * SUB-PROSES: SP-1 (Intel & Plan) - Organizing (Breakdown)
 * 
 * INPUT:
 * - id_spk: string (UUID, from URL parameter)
 * - arrayTugas: array of objects
 *   [
 *     {
 *       id_pelaksana: string (UUID, FK ke master_pihak),
 *       tipe_tugas: string (max 15 chars, FK ke tupoksi_tipe),
 *       target_json: object (blok, id_pohon, dll),
 *       prioritas: number (optional, 1-3, default: 2)
 *     }
 *   ]
 * 
 * OUTPUT:
 * {
 *   id_spk: string,
 *   jumlah_tugas_ditambahkan: number,
 *   tugas: array of created tasks with id_tugas
 * }
 * 
 * VALIDASI BISNIS:
 * 1. id_spk harus exist di tabel spk_header
 * 2. id_pelaksana harus exist di tabel master_pihak (FK constraint)
 * 3. tipe_tugas harus exist di tabel tupoksi_tipe (FK constraint)
 * 4. target_json harus valid JSON (akan di-stringify jika object)
 * 5. prioritas default = 2 (Sedang) jika tidak diisi
 * 6. status_tugas default = 'BARU' (dari database default)
 * 
 * PRINSIP MPP:
 * - SIMPLE: Batch insert dalam 1 call
 * - TEPAT: Validasi FK untuk setiap item, sanitasi input
 * - PENINGKATAN BERTAHAB: Auto-generated id_tugas, status_tugas
 */
async function addTugasKeSpk(id_spk, arrayTugas) {
  try {
    console.log('ðŸ“ [Service] Adding tugas to SPK...');
    console.log('   ID SPK:', id_spk);
    console.log('   Jumlah Tugas:', arrayTugas.length);
    
    // Prinsip TEPAT: Validasi bahwa SPK Header exist
    const { data: spkExists, error: spkError } = await supabase
      .from('spk_header')
      .select('id_spk, nama_spk, status_spk')
      .eq('id_spk', id_spk)
      .single();
    
    if (spkError || !spkExists) {
      throw new Error(`SPK dengan ID '${id_spk}' tidak ditemukan`);
    }
    
    console.log('âœ… SPK ditemukan:', spkExists.nama_spk);
    console.log('   Status SPK:', spkExists.status_spk);
    
    // Prinsip KEAMANAN: Validasi FK untuk setiap tugas
    // 1. Validasi semua id_pelaksana exist di master_pihak
    const uniquePelaksanaIds = [...new Set(arrayTugas.map(t => t.id_pelaksana))];
    console.log('ðŸ” Validasi ID Pelaksana:', uniquePelaksanaIds);
    
    const { data: pelaksanaData, error: pelaksanaError } = await supabase
      .from('master_pihak')
      .select('id_pihak')
      .in('id_pihak', uniquePelaksanaIds);
    
    if (pelaksanaError) {
      throw new Error(`Gagal validasi ID Pelaksana: ${pelaksanaError.message}`);
    }
    
    const foundPelaksanaIds = pelaksanaData.map(p => p.id_pihak);
    const missingPelaksanaIds = uniquePelaksanaIds.filter(id => !foundPelaksanaIds.includes(id));
    
    if (missingPelaksanaIds.length > 0) {
      throw new Error(`ID Pelaksana tidak ditemukan: ${missingPelaksanaIds.join(', ')}`);
    }
    
    console.log('âœ… Semua ID Pelaksana valid');
    
    // 2. Validasi semua tipe_tugas exist di tupoksi_tipe (optional, bisa skip jika tidak ada tabel)
    // NOTE: Jika tabel tupoksi_tipe belum ada, comment validasi ini
    const uniqueTipeTugas = [...new Set(arrayTugas.map(t => t.tipe_tugas))];
    console.log('ðŸ” Tipe Tugas:', uniqueTipeTugas);
    
    // Skip FK validation untuk tipe_tugas jika tabel tupoksi_tipe tidak ada
    // Uncomment kode di bawah jika tabel tupoksi_tipe sudah dibuat:
    /*
    const { data: tipeTugasData, error: tipeTugasError } = await supabase
      .from('tupoksi_tipe')
      .select('kode_tipe')
      .in('kode_tipe', uniqueTipeTugas);
    
    if (tipeTugasError) {
      console.log('âš ï¸  Warning: Tabel tupoksi_tipe tidak ada, skip validasi tipe_tugas');
    } else {
      const foundTipeTugas = tipeTugasData.map(t => t.kode_tipe);
      const missingTipeTugas = uniqueTipeTugas.filter(tipe => !foundTipeTugas.includes(tipe));
      
      if (missingTipeTugas.length > 0) {
        throw new Error(`Tipe Tugas tidak valid: ${missingTipeTugas.join(', ')}`);
      }
      
      console.log('âœ… Semua Tipe Tugas valid');
    }
    */
    
    // Prinsip KEAMANAN: Sanitasi dan prepare data untuk batch insert
    const tugasToInsert = arrayTugas.map(tugas => {
      // Sanitasi string inputs
      const sanitized = {
        id_spk: id_spk.trim(),
        id_pelaksana: tugas.id_pelaksana.trim(),
        tipe_tugas: tugas.tipe_tugas.trim().toUpperCase(), // Normalize ke uppercase
        // target_json: harus di-stringify jika object (Supabase PostgreSQL jsonb)
        target_json: typeof tugas.target_json === 'string' 
          ? tugas.target_json 
          : JSON.stringify(tugas.target_json),
        prioritas: tugas.prioritas || 2 // Default: 2 (Sedang)
        // id_tugas, status_tugas akan auto-generated oleh database
      };
      
      return sanitized;
    });
    
    console.log('ðŸ“¦ Prepared data untuk insert:', tugasToInsert.length, 'tugas');
    
    // BATCH INSERT ke tabel spk_tugas
    // Prinsip SKALABILITAS: Insert multiple rows dalam 1 query
    const { data, error } = await supabase
      .from('spk_tugas')
      .insert(tugasToInsert)
      .select(); // PENTING: .select() untuk return data yang baru di-insert
    
    if (error) {
      console.error('âŒ [Service] Supabase BATCH INSERT error:', error);
      throw new Error(`Gagal insert tugas: ${error.message}`);
    }
    
    if (!data || data.length === 0) {
      throw new Error('Gagal insert tugas: No data returned');
    }
    
    console.log('âœ… [Service] Batch insert berhasil!');
    console.log('   Jumlah tugas ditambahkan:', data.length);
    
    // Return data sesuai kontrak API
    return {
      id_spk: id_spk,
      jumlah_tugas_ditambahkan: data.length,
      tugas: data.map(t => ({
        id_tugas: t.id_tugas,
        id_pelaksana: t.id_pelaksana,
        tipe_tugas: t.tipe_tugas,
        status_tugas: t.status_tugas,
        target_json: typeof t.target_json === 'string' 
          ? JSON.parse(t.target_json) 
          : t.target_json,
        prioritas: t.prioritas
      }))
    };
    
  } catch (err) {
    console.error('âŒ [Service] Error in addTugasKeSpk:', err.message);
    throw err; // Re-throw untuk di-catch oleh router layer
  }
}

// ============================================================
// PLACEHOLDER FUNCTIONS (BELUM DIIMPLEMENTASIKAN)
// ============================================================

/**
 * 1. Create Work Order (SPK Tugas - Detail)
 * [PLACEHOLDER - Belum diimplementasikan]
 * 
 * Catatan: Ini berbeda dengan createSpkHeader.
 * - createSpkHeader = Buat SPK Induk (Header)
 * - createWorkOrder = Buat Tugas Spesifik (Detail) yang terikat ke SPK Header
 */
async function createWorkOrder(data) {
  // TODO: Implementasi create Work Order (spk_tugas)
  throw new Error('Function createWorkOrder belum diimplementasikan');
}

/**
 * 2. Lapor Validasi + Auto-Trigger
 * [PLACEHOLDER - Belum diimplementasikan]
 */
async function laporValidasi(data) {
  // TODO: Implementasi lapor validasi
  // TODO: Implementasi auto-trigger WO APH/Sanitasi
  throw new Error('Function laporValidasi belum diimplementasikan');
}

/**
 * 3. Lapor APH
 * [PLACEHOLDER - Belum diimplementasikan]
 */
async function laporAph(data) {
  // TODO: Implementasi lapor APH
  throw new Error('Function laporAph belum diimplementasikan');
}

/**
 * 4. Lapor Sanitasi
 * [PLACEHOLDER - Belum diimplementasikan]
 */
async function laporSanitasi(data) {
  // TODO: Implementasi lapor sanitasi
  throw new Error('Function laporSanitasi belum diimplementasikan');
}

/**
 * 5. Get Daftar Tugas (dengan Paginasi)
 * [PLACEHOLDER - Belum diimplementasikan]
 */
async function getDaftarTugas(filters) {
  // TODO: Implementasi get daftar tugas
  // TODO: Implementasi paginasi
  throw new Error('Function getDaftarTugas belum diimplementasikan');
}

// ============================================================
// SUB-PROSES 2: ACTUATING & REPORTING (Platform A)
// ============================================================

/**
 * Get Tugas Saya (untuk Pelaksana/Mandor)
 * 
 * TUJUAN: Dipanggil oleh Platform A (Flutter) saat sinkronisasi di kantor
 * FITUR: Sub-Proses 2.1 - Mengambil Tugas
 * KEAMANAN: id_pelaksana dari JWT token (req.user.id_pihak)
 * 
 * INPUT:
 * - id_pelaksana: string (UUID dari JWT token)
 * - options: {
 *     page: number (default: 1),
 *     limit: number (default: 100),
 *     status: array of string (default: ['BARU', 'DIKERJAKAN'])
 *   }
 * 
 * OUTPUT:
 * {
 *   tugas: array of tugas objects,
 *   pagination: {
 *     page: number,
 *     limit: number,
 *     total_items: number,
 *     total_pages: number,
 *     has_next: boolean,
 *     has_prev: boolean
 *   }
 * }
 * 
 * PRINSIP MPP:
 * - SIMPLE: Query straightforward dengan pagination
 * - TEPAT: id_pelaksana dari JWT (trusted), bukan dari query param
 * - SKALABILITAS: Pagination wajib untuk handle ribuan tugas
 */
async function getTugasSaya(id_pelaksana, options = {}) {
  try {
    console.log('ðŸ“± [Service] Get Tugas Saya...');
    console.log('   ID Pelaksana:', id_pelaksana);
    console.log('   Options:', JSON.stringify(options, null, 2));
    
    // Default options
    const page = options.page || 1;
    const limit = options.limit || 100;
    const statusFilter = options.status || ['BARU', 'DIKERJAKAN'];
    
    // Calculate offset untuk pagination
    const offset = (page - 1) * limit;
    
    // Prinsip TEPAT: Validasi pelaksana exist
    const { data: pelaksanaExists, error: checkError } = await supabase
      .from('master_pihak')
      .select('id_pihak, nama, tipe')
      .eq('id_pihak', id_pelaksana)
      .single();
    
    if (checkError || !pelaksanaExists) {
      throw new Error(`ID Pelaksana '${id_pelaksana}' tidak ditemukan di master_pihak`);
    }
    
    console.log('âœ… Pelaksana valid:', pelaksanaExists.nama, '(' + pelaksanaExists.tipe + ')');
    
    // Query tugas dengan pagination
    // Prinsip SKALABILITAS: Use range() untuk pagination
    const { data: tugasData, error: tugasError, count } = await supabase
      .from('spk_tugas')
      .select('*', { count: 'exact' }) // count untuk total items
      .eq('id_pelaksana', id_pelaksana)
      .in('status_tugas', statusFilter)
      .order('prioritas', { ascending: true }) // Order by prioritas (1=Tinggi first)
      .range(offset, offset + limit - 1); // Pagination
    
    if (tugasError) {
      console.error('âŒ [Service] Supabase query error:', tugasError);
      throw new Error(`Gagal query tugas: ${tugasError.message}`);
    }
    
    const tugas = tugasData || [];
    const totalItems = count || 0;
    const totalPages = Math.ceil(totalItems / limit);
    
    console.log('âœ… [Service] Query berhasil');
    console.log('   Tugas ditemukan:', tugas.length);
    console.log('   Total items:', totalItems);
    console.log('   Total pages:', totalPages);
    
    // Parse target_json (jika string, convert ke object)
    const tugasParsed = tugas.map(t => ({
      ...t,
      target_json: typeof t.target_json === 'string' 
        ? JSON.parse(t.target_json) 
        : t.target_json
    }));
    
    // Return dengan metadata pagination
    return {
      tugas: tugasParsed,
      pagination: {
        page: page,
        limit: limit,
        total_items: totalItems,
        total_pages: totalPages,
        has_next: page < totalPages,
        has_prev: page > 1
      }
    };
    
  } catch (err) {
    console.error('âŒ [Service] Error in getTugasSaya:', err.message);
    throw err;
  }
}

/**
 * Upload Log Aktivitas 5W1H (Batch)
 * 
 * TUJUAN: Dipanggil oleh Platform A (Flutter) untuk upload Jejak Digital
 * FITUR: Sub-Proses 2.1, 2.3, 2.4 - Melaporkan Hasil Eksekusi
 * 
 * INI ADALAH FUNCTION PALING KOMPLEKS & PENTING!
 * 
 * INPUT:
 * - id_petugas: string (UUID dari JWT token - WHO)
 * - arrayLog: array of log objects
 *   [
 *     {
 *       id_tugas: string (WHAT),
 *       id_npokok: string (WHERE - pohon),
 *       timestamp_eksekusi: string (WHEN - ISO 8601),
 *       gps_eksekusi: object (WHERE - lat/lon),
 *       hasil_json: object (HOW - results)
 *     }
 *   ]
 * 
 * OUTPUT:
 * {
 *   log_diterima: number,
 *   log_berhasil: number,
 *   log_gagal: number,
 *   errors: array (jika ada),
 *   auto_trigger: {
 *     work_order_created: number,
 *     tugas_updated: number
 *   }
 * }
 * 
 * PRINSIP MPP:
 * - SIMPLE: Batch insert log_aktivitas_5w1h
 * - TEPAT: 
 *   - Validasi FK (id_tugas exist)
 *   - id_petugas dari JWT (JANGAN PERCAYA INPUT)
 *   - Timestamp server (bukan dari HP untuk created_at)
 * - PENINGKATAN BERTAHAB: 
 *   - Auto-update status_tugas
 *   - Auto-trigger Work Order baru (APH/Sanitasi) jika status_aktual = 'G1' atau 'G4'
 * 
 * VALIDASI BISNIS:
 * 1. Setiap id_tugas harus exist di spk_tugas
 * 2. timestamp_eksekusi harus valid ISO 8601
 * 3. gps_eksekusi harus valid lat/lon
 * 4. hasil_json harus valid JSON
 * 
 * AUTO-TRIGGER (KRUSIAL):
 * 1. Setelah INSERT log, update status_tugas:
 *    - Jika log pertama untuk tugas ini: BARU -> DIKERJAKAN
 *    - Jika semua pohon selesai: DIKERJAKAN -> SELESAI
 * 2. Jika hasil_json.status_aktual = 'G1' atau 'G4':
 *    - CREATE Work Order baru untuk APH/Sanitasi
 *    - Link ke SPK parent yang sama
 */
async function uploadLogAktivitas5W1H(id_petugas, arrayLog) {
  try {
    console.log('ðŸ“± [Service] Upload Log Aktivitas 5W1H...');
    console.log('   ID Petugas (WHO):', id_petugas);
    console.log('   Jumlah Log:', arrayLog.length);
    
    // Prinsip TEPAT: Validasi petugas exist
    const { data: petugasExists, error: checkError } = await supabase
      .from('master_pihak')
      .select('id_pihak, nama')
      .eq('id_pihak', id_petugas)
      .single();
    
    if (checkError || !petugasExists) {
      throw new Error(`ID Petugas '${id_petugas}' tidak ditemukan di master_pihak`);
    }
    
    console.log('âœ… Petugas valid:', petugasExists.nama);
    
    // Prepare untuk collect results
    const logBerhasil = [];
    const logGagal = [];
    const tugasUpdated = new Set(); // Track tugas yang sudah di-update statusnya
    const workOrdersToCreate = []; // Track WO yang perlu di-create
    
    // Prinsip TEPAT: Validasi FK untuk semua id_tugas dulu (batch check)
    const uniqueTugasIds = [...new Set(arrayLog.map(log => log.id_tugas))];
    console.log('ðŸ” Validasi ID Tugas:', uniqueTugasIds.length, 'unique');
    
    const { data: tugasData, error: tugasError } = await supabase
      .from('spk_tugas')
      .select('id_tugas, id_spk, tipe_tugas, status_tugas')
      .in('id_tugas', uniqueTugasIds);
    
    if (tugasError) {
      throw new Error(`Gagal validasi ID Tugas: ${tugasError.message}`);
    }
    
    // Create lookup map untuk faster check
    const tugasLookup = {};
    tugasData.forEach(t => {
      tugasLookup[t.id_tugas] = t;
    });
    
    // Prepare data untuk batch insert
    const logsToInsert = [];
    
    arrayLog.forEach((log, index) => {
      try {
        // Validasi: id_tugas exist?
        if (!tugasLookup[log.id_tugas]) {
          logGagal.push({
            index: index,
            error: `id_tugas '${log.id_tugas}' tidak ditemukan`
          });
          return; // Skip log ini
        }
        
        // Sanitasi dan prepare data
        const logData = {
          id_tugas: log.id_tugas.trim(),
          id_npokok: log.id_npokok.trim(),
          id_petugas: id_petugas, // WHO dari JWT (TRUSTED)
          timestamp_eksekusi: log.timestamp_eksekusi, // WHEN dari HP
          // created_at akan auto-filled oleh database (WHEN di server)
          gps_eksekusi: typeof log.gps_eksekusi === 'string' 
            ? log.gps_eksekusi 
            : JSON.stringify(log.gps_eksekusi), // WHERE
          hasil_json: typeof log.hasil_json === 'string' 
            ? log.hasil_json 
            : JSON.stringify(log.hasil_json) // HOW
        };
        
        logsToInsert.push(logData);
        
        // Prinsip PENINGKATAN BERTAHAB: Check untuk auto-trigger
        const hasilObj = typeof log.hasil_json === 'string' 
          ? JSON.parse(log.hasil_json) 
          : log.hasil_json;
        
        // Auto-trigger Work Order jika status_aktual = 'G1' atau 'G4'
        if (hasilObj.status_aktual === 'G1' || hasilObj.status_aktual === 'G4') {
          const tugasInfo = tugasLookup[log.id_tugas];
          
          workOrdersToCreate.push({
            id_spk: tugasInfo.id_spk, // Link ke SPK parent yang sama
            id_pelaksana: id_petugas, // Assign ke petugas yang sama (atau bisa custom)
            tipe_tugas: hasilObj.status_aktual === 'G1' ? 'APH' : 'SANITASI',
            target_json: {
              id_npokok: log.id_npokok,
              blok: hasilObj.blok || 'Unknown',
              triggered_by: log.id_tugas,
              alasan: `Auto-trigger dari validasi: ${hasilObj.status_aktual} - ${hasilObj.keterangan || 'N/A'}`
            },
            prioritas: 1, // High priority untuk follow-up
            catatan: `Auto-generated dari log validasi (status: ${hasilObj.status_aktual})`
          });
        }
        
        // Track tugas untuk status update
        tugasUpdated.add(log.id_tugas);
        
      } catch (err) {
        logGagal.push({
          index: index,
          error: err.message
        });
      }
    });
    
    console.log('ðŸ“¦ Prepared logs:', logsToInsert.length, 'valid');
    console.log('âš™ï¸  Auto-trigger WO:', workOrdersToCreate.length);
    
    // BATCH INSERT log_aktivitas_5w1h
    let insertedCount = 0;
    if (logsToInsert.length > 0) {
      const { data: insertedLogs, error: insertError } = await supabase
        .from('log_aktivitas_5w1h')
        .insert(logsToInsert)
        .select();
      
      if (insertError) {
        console.error('âŒ [Service] Supabase INSERT error:', insertError);
        // Jangan throw, karena mungkin sebagian berhasil
        // Log error tapi lanjutkan
        logGagal.push({
          index: -1,
          error: `Batch insert failed: ${insertError.message}`
        });
      } else {
        insertedCount = insertedLogs ? insertedLogs.length : 0;
        console.log('âœ… [Service] Batch insert log berhasil:', insertedCount);
      }
    }
    
    // AUTO-TRIGGER 1: Update status_tugas
    let tugasUpdatedCount = 0;
    for (const id_tugas of tugasUpdated) {
      try {
        const tugasInfo = tugasLookup[id_tugas];
        
        // Logika update status:
        // - Jika status_tugas = 'BARU' -> update ke 'DIKERJAKAN'
        // - Jika semua log untuk tugas ini sudah ada -> update ke 'SELESAI'
        // (Untuk simplicity, kita update ke DIKERJAKAN dulu)
        
        if (tugasInfo.status_tugas === 'BARU') {
          const { error: updateError } = await supabase
            .from('spk_tugas')
            .update({ status_tugas: 'DIKERJAKAN' })
            .eq('id_tugas', id_tugas);
          
          if (!updateError) {
            tugasUpdatedCount++;
            console.log('âœ… Status tugas updated:', id_tugas, 'BARU -> DIKERJAKAN');
          }
        }
      } catch (err) {
        console.error('âš ï¸  Warning: Gagal update status tugas', id_tugas, ':', err.message);
        // Jangan throw, lanjutkan
      }
    }
    
    // AUTO-TRIGGER 2: Create Work Order baru (APH/Sanitasi)
    let workOrderCreatedCount = 0;
    if (workOrdersToCreate.length > 0) {
      console.log('ðŸ”§ Creating', workOrdersToCreate.length, 'auto-triggered Work Orders...');
      
      const { data: createdWO, error: woError } = await supabase
        .from('spk_tugas')
        .insert(workOrdersToCreate)
        .select();
      
      if (woError) {
        console.error('âš ï¸  Warning: Gagal create Work Orders:', woError.message);
        // Jangan throw, ini optional
      } else {
        workOrderCreatedCount = createdWO ? createdWO.length : 0;
        console.log('âœ… Work Orders created:', workOrderCreatedCount);
      }
    }
    
    console.log('âœ… [Service] Upload Log Aktivitas selesai!');
    console.log('   Log berhasil:', insertedCount);
    console.log('   Log gagal:', logGagal.length);
    console.log('   Tugas updated:', tugasUpdatedCount);
    console.log('   Work Order created:', workOrderCreatedCount);
    
    // Return summary
    return {
      log_diterima: arrayLog.length,
      log_berhasil: insertedCount,
      log_gagal: logGagal.length,
      errors: logGagal.length > 0 ? logGagal : undefined,
      auto_trigger: {
        work_order_created: workOrderCreatedCount,
        tugas_updated: tugasUpdatedCount
      }
    };
    
  } catch (err) {
    console.error('âŒ [Service] Error in uploadLogAktivitas5W1H:', err.message);
    throw err;
  }
}

// ============================================================
// HELPER FUNCTIONS (PLACEHOLDER)
// ============================================================

/**
 * Helper: Validasi input data
 * [PLACEHOLDER - Belum diimplementasikan]
 */
function validateInput(data, requiredFields) {
  // TODO: Implementasi validasi
  // Contoh: Check required fields, tipe data, format
  return { valid: true, errors: [] };
}

/**
 * Helper: Auto-trigger Work Order berdasarkan kondisi
 * [PLACEHOLDER - Belum diimplementasikan]
 */
async function autoTriggerWorkOrder(statusAktual, idNpokok) {
  // TODO: Implementasi auto-trigger logic
  // IF statusAktual = 'G1' -> createWorkOrder({ tipe_tugas: 'APH', ... })
  // IF statusAktual = 'G3' OR 'G4' -> createWorkOrder({ tipe_tugas: 'SANITASI', ... })
  return null;
}

/**
 * Helper: Insert Log Aktivitas 5W1H
 * [PLACEHOLDER - Belum diimplementasikan]
 */
async function insertLogAktivitas5W1H(data) {
  // TODO: Implementasi insert log
  // Wajib capture: Who, What, When, Where, Why, How
  return null;
}

// ============================================================
// EXPORTS
// ============================================================

module.exports = {
  createSpkHeader,
  addTugasKeSpk,
  getTugasSaya,
  uploadLogAktivitas5W1H,
  createWorkOrder,
  laporValidasi,
  laporAph,
  laporSanitasi,
  getDaftarTugas,
  // Export helpers untuk testing (optional)
  validateInput,
  autoTriggerWorkOrder,
  insertLogAktivitas5W1H
};
